using System.Collections.Immutable;
using System.Text;
using System.Text.Json;
using IeuanWalker.Hangfire.Utilties;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace IeuanWalker.Hangfire;

[Generator(LanguageNames.CSharp)]
public class RecuringJobGenerator2 : IIncrementalGenerator
{
	const string attribName = "RecurringJob";

	public virtual void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var syntaxSymbols = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: Match,
				transform: Transform
			)
			.Where(item => item is not (null, null))
			.Collect();

		context.RegisterSourceOutput(syntaxSymbols, Generate);
	}


	protected bool Match(SyntaxNode node, CancellationToken cancellationToken)
	{
		if (node is not AttributeSyntax attributeSyntax)
		{
			return false;
		}

		var name = SyntaxUtil.ExtractName(attributeSyntax.Name);

		return name?.Contains(attribName) ?? false;
	}

	protected virtual (SyntaxNode?, ISymbol?) Transform(GeneratorSyntaxContext context,
		CancellationToken cancellationToken)
	{
		var attributeSyntax = (AttributeSyntax)context.Node;

		string jsonString = JsonSerializer.Serialize(attributeSyntax);

		// Attribute --> AttributeList --> Class
		if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classDeclarationSyntax)
		{
			return (null, null);
		}



		var classSymbol = context.SemanticModel
			.Compilation
			.GetTypeByMetadataName(
				SyntaxUtil.GetClassFullname(classDeclarationSyntax)
			);

		return (classDeclarationSyntax, classSymbol);
	}

	protected virtual void Generate(SourceProductionContext context,
		ImmutableArray<(SyntaxNode?, ISymbol?)> syntaxSymbols)
	{
		if (syntaxSymbols.IsDefaultOrEmpty)
		{
			return;
		}

		var groupList = syntaxSymbols.GroupBy<(SyntaxNode, ISymbol), ClassDeclarationSyntax>(
			fieldGroup => (ClassDeclarationSyntax)fieldGroup.Item1!.Parent!
		);

		foreach (var group in groupList)
		{
			var sourceCode = ProcessClass(group.Key, group.ToList()).Trim();
			var className = SyntaxUtil.GetClassFullname(group.Key);

			context.AddSource($"{className}.g.cs", sourceCode);
		}
	}

	protected virtual string ProcessClass(ClassDeclarationSyntax? classSyntax,
		List<(SyntaxNode, ISymbol)> syntaxSymbols)
	{
		if (classSyntax is null)
		{
			return string.Empty;
		}

		var usingDirectives = classSyntax.SyntaxTree.GetCompilationUnitRoot().Usings;

		var namespaceSyntax = classSyntax.Parent as BaseNamespaceDeclarationSyntax;
		var namespaceName = namespaceSyntax?.Name.ToString() ?? "global";

		var source = new StringBuilder($@"
#pragma warning disable

// <auto-generated/>
{usingDirectives}

namespace {namespaceName}
{{
    public partial class {classSyntax.Identifier}
    {{
");

		foreach (var (syntax, symbol) in syntaxSymbols)
		{
			ProcessField(source, classSyntax, syntax, symbol);
		}

		source.Append(@$"
    }}
}}
");

		return source.ToString();
	}

	protected virtual string ProcessClass((SyntaxNode, ISymbol) group)
	{
		return string.Empty;
	}

	protected virtual void ProcessField(StringBuilder source, ClassDeclarationSyntax classSyntax,
		SyntaxNode fieldSyntax, ISymbol fieldSymbol)
	{
	}
}

