using System.Collections.Immutable;
using System.Text;
using IeuanWalker.Hangfire.Attributes;
using IeuanWalker.Hangfire.Helpers;
using IeuanWalker.Hangfire.Interfaces;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace IeuanWalker.Hangfire;

[Generator(LanguageNames.CSharp)]
public class RecuringJobGenerator : IIncrementalGenerator
{
	static readonly StringBuilder b = new();
	static string? assemblyName;
	const string fullAttribute = "IeuanWalker.Hangfire.RecurringJob.RecurringJobAttribute";

	/// <summary>
	/// Starts the generator
	/// </summary>
	/// <param name="context"></param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Constant classes/ interfaces for the users to use
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"RecurringJobAttribute.g.cs",
			SourceText.From(RecurringJobAttribute.Attribute, Encoding.UTF8)));
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"IRecurringJob.g.cs",
			SourceText.From(RecurringJobInterface.InterfaceVoid, Encoding.UTF8)));
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"IRecurringJobAsync.g.cs",
			SourceText.From(RecurringJobInterface.InterfaceAsync, Encoding.UTF8)));

		//Generator implementation
		var enumDeclarations = context.SyntaxProvider
		   .CreateSyntaxProvider(
			   predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
			   transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
		   .Where(static m => m is not null)
		   .Collect();

		context.RegisterSourceOutput(enumDeclarations, Generate!);
	}


	static bool IsSyntaxTargetForGeneration(SyntaxNode node) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

	static List<HangfireJobToGenerate>? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
	{
		if (context.Node is not ClassDeclarationSyntax classSyntax)
		{
			return null;
		}
		var classSymbol = context.SemanticModel.GetDeclaredSymbol(classSyntax);
		if (classSymbol is null)
		{
			return null;
		}

		assemblyName = context.SemanticModel.Compilation.AssemblyName;
		string fullClassName = classSymbol.ToDisplayString() ?? throw new NullReferenceException();

		var attributes = classSymbol.GetAttributes();

		List<HangfireJobToGenerate?> registrations = attributes
			.Select(x => CreateServiceRegistration(x, fullClassName))
			.Where(x => x is not null)
			.ToList();

		if (registrations.Count == 0)
		{
			return null;
		}

		return registrations.Where(x => x is not null).Select(x => x!).ToList();
	}

	static HangfireJobToGenerate? CreateServiceRegistration(AttributeData attribute, string fullClassName)
	{
		// Is recuring job attribute
		if (attribute.ToString() != fullAttribute)
		{
			return null;
		}

		// properties
		string? jobId = null;
		string? cron = null;
		string? queue = null;
		string? timeZone = null;

		foreach (var parameter in attribute.NamedArguments)
		{
			// match name with service registration configuration
			var name = parameter.Key;
			var value = parameter.Value.Value;

			if (string.IsNullOrEmpty(name) || value == null)
			{
				continue;
			}

			switch (name)
			{
				case "JobId":
					jobId = value.ToString();
					break;
				case "Cron":
					cron = value.ToString();
					break;
				case "Queue":
					queue = value.ToString();
					break;
				case "TimeZone":
					timeZone = value.ToString();
					break;
			}
		}

		if (jobId is null || cron is null || queue is null || timeZone is null)
		{
			return null;
		}

		return new HangfireJobToGenerate(fullClassName, jobId, cron, queue, timeZone);
	}


	static void Generate(SourceProductionContext context, ImmutableArray<List<HangfireJobToGenerate>> jobs)
	{
		if (!jobs.Any())
		{
			return;
		}

		var allJobs = jobs.SelectMany(x => x).ToList();

		b.Clear().Append(
"namespace ").Append(assemblyName).Append(@";

// <auto-generated/>

using Hangfire;
using Microsoft.Extensions.DependencyInjection;

public static class RecurringJobRegistrationExtensions
{
    public static IServiceCollection RegisterRecurringJobsFrom").Append(assemblyName?.Sanitize(string.Empty) ?? "Assembly").Append(@"(this IServiceCollection sc)
    {
");
		foreach (var job in allJobs.OrderBy(r => r!.JobId))
		{
			b.Append("\t\tRecurringJob.AddOrUpdate<").Append(job.FullClassName).Append(">(\"").Append(job.JobId).Append("\"").Append(", x => x.Execute(), \"").Append(job.Cron).Append("\");").Append("\r\n");
		}
		b.Append(@"
        return sc;
    }
}");
		string test = b.ToString();
		context.AddSource("RecurringJobRegistrationExtensions.g.cs", SourceText.From(b.ToString(), Encoding.UTF8));
	}
}

public class HangfireJobToGenerate
{
	public HangfireJobToGenerate(string fullClassName, string jobId, string cron, string queue, string timeZone)
	{
		FullClassName = fullClassName;
		JobId = jobId;
		Cron = cron;
		Queue = queue;
		TimeZone = timeZone;
	}
	public string FullClassName { get; set; }
	public string? JobId { get; set; }
	public string Cron { get; set; }
	public string Queue { get; set; }
	public string TimeZone { get; set; }
}